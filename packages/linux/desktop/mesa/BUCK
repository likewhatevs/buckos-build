load("//defs:package_defs.bzl", "download_source", "meson_package")
load("//defs:use_flags.bzl", "set_use_flags")

# =============================================================================
# Mesa - OpenGL and Vulkan implementation
# =============================================================================

meson_package(
    name = "mesa",
    version = "26.0.0",
    src_uri = "https://archive.mesa3d.org/mesa-26.0.0.tar.xz",
    sha256 = "2a44e98e64d5c36cec64633de2d0ec7eff64703ee25b35364ba8fcaa84f33f72",
    signature_required = False,
    description = "Mesa 3D Graphics Library - OpenGL and Vulkan",
    homepage = "https://www.mesa3d.org/",
    license = "MIT",
    # Mesa 26.0.0+ has proper wayland-scanner detection, patch may not be needed
    patches = [],
    # Fix meson.options vs meson_options.txt conflict and header stub issues
    src_prepare = '''
# Remove meson_options.txt if meson.options exists (meson 1.0+ conflict)
if [ -f meson.options ] && [ -f meson_options.txt ]; then
    rm -f meson_options.txt
fi

# Remove stub headers that shadow generated headers during build
# spirv_info.h stub shadows the generated version with full struct definitions
if [ -f src/compiler/spirv/spirv_info.h ]; then
    echo "Removing spirv_info.h stub (will be generated during build)"
    rm -f src/compiler/spirv/spirv_info.h
fi

# CRITICAL: Mesa 26.0.0 has deprecated ac_nir.* files in src/amd/common/ that
# shadow the new ac_nir.* files in src/amd/common/nir/
# The old files lack functions like ac_nir_store_may_be_subdword, ac_nir_lower_phis_to_scalar_cb etc.
# These old files must be removed to use the correct newer headers
if [ -d src/amd/common/nir ] && [ -f src/amd/common/ac_nir.h ]; then
    echo "Removing deprecated ac_nir files from src/amd/common/ (superseded by src/amd/common/nir/)"
    rm -f src/amd/common/ac_nir.c
    rm -f src/amd/common/ac_nir.h
    rm -f src/amd/common/ac_nir_cull.c
    rm -f src/amd/common/ac_nir_lower_esgs_io_to_mem.c
    rm -f src/amd/common/ac_nir_lower_global_access.c
    rm -f src/amd/common/ac_nir_lower_image_opcodes_cdna.c
    rm -f src/amd/common/ac_nir_lower_ngg.c
    rm -f src/amd/common/ac_nir_lower_ps.c
    rm -f src/amd/common/ac_nir_lower_resinfo.c
    rm -f src/amd/common/ac_nir_lower_subdword_loads.c
    rm -f src/amd/common/ac_nir_lower_taskmesh_io_to_mem.c
    rm -f src/amd/common/ac_nir_lower_tess_io_to_mem.c
    rm -f src/amd/common/ac_nir_lower_tex.c
    rm -f src/amd/common/ac_nir_opt_outputs.c
fi
''',
    iuse = ["X", "wayland", "vulkan", "llvm"],
    # llvm enables radeonsi for AMD GPUs (requires LLVM 15+)
    use_defaults = ["wayland", "llvm"],
    # Python mako is needed for code generation
    # wayland provides wayland-scanner needed during build
    bdepend = [
        "//packages/linux/dev-libs/python/mako:mako",
        "//packages/linux/dev-libs/python/markupsafe:markupsafe",
    ],
    # wayland-scanner provides native wayland-scanner for host (exec_bdepend builds for host platform)
    exec_bdepend = [
        "//packages/linux/graphics/rendering/wayland:wayland-scanner",
    ],
    # Set PYTHONPATH to find mako from bdepends
    # Also set up wayland-scanner from exec_bdepend (HOST_TOOL_DIRS)
    pre_configure = '''
# Find python packages from bdepends (DEP_BASE_DIRS)
IFS=':' read -ra DEP_ARRAY <<< "$DEP_BASE_DIRS"
for dep_dir in "${DEP_ARRAY[@]}"; do
    if [ -d "$dep_dir/lib/python" ]; then
        export PYTHONPATH="$dep_dir/lib/python${PYTHONPATH:+:$PYTHONPATH}"
    fi
done

# Find wayland-scanner from exec_bdepend (HOST_TOOL_DIRS or _EBUILD_HOST_TOOL_DIRS)
HOST_DIRS="${HOST_TOOL_DIRS:-$_EBUILD_HOST_TOOL_DIRS}"
if [ -n "$HOST_DIRS" ]; then
    IFS=':' read -ra HOST_ARRAY <<< "$HOST_DIRS"
    for host_dir in "${HOST_ARRAY[@]}"; do
        if [ -x "$host_dir/usr/bin/wayland-scanner" ]; then
            WAYLAND_SCANNER="$host_dir/usr/bin/wayland-scanner"
            SCANNER_DIR="$host_dir/usr/bin"
            SCANNER_PKG_CONFIG_PATH="$host_dir/usr/lib64/pkgconfig"
            echo "Found wayland-scanner: $WAYLAND_SCANNER"

            # Create patched pkg-config directory
            mkdir -p patched_pkgconfig
            if [ -f "$SCANNER_PKG_CONFIG_PATH/wayland-scanner.pc" ]; then
                sed "s|^prefix=.*|prefix=$host_dir/usr|" "$SCANNER_PKG_CONFIG_PATH/wayland-scanner.pc" > patched_pkgconfig/wayland-scanner.pc
                echo "Patched wayland-scanner.pc to use prefix=$host_dir/usr"
            fi

            # Create meson native file with scanner path
            cat > native.ini << NEOF
[binaries]
wayland-scanner = '$WAYLAND_SCANNER'

[built-in options]
pkg_config_path = ['$(pwd)/patched_pkgconfig', '$SCANNER_PKG_CONFIG_PATH']
NEOF
            echo "Created native.ini with wayland-scanner path"
            break
        fi
    done
fi
echo "PYTHONPATH=$PYTHONPATH"
''',
    # Use native file for meson to find wayland-scanner
    src_configure = '''
rm -rf "${BUILD_DIR:-build}"

# Filter LTO flags - mesa has issues with LTO (per Gentoo ebuild: filter-lto)
# See https://gitlab.freedesktop.org/mesa/mesa/-/issues/11140
filter_lto() {
    echo "$1" | sed -E 's/-flto[^ ]*//g; s/-ffat-lto-objects//g' | tr -s ' '
}
export CFLAGS="$(filter_lto "$CFLAGS")"
export CXXFLAGS="$(filter_lto "$CXXFLAGS")"
export LDFLAGS="$(filter_lto "$LDFLAGS")"
echo "Filtered LTO flags from compiler/linker flags"

# Fix: Remove C++ includes from CPPFLAGS - they cause C stdatomic.h to be shadowed
# by the C++ version which doesn't define atomic_bool/atomic_size_t for C code
# Handle both -isystem /path and -isystem/path forms
CPPFLAGS_FIXED=""
SKIP_NEXT=0
set -- $CPPFLAGS
while [ $# -gt 0 ]; do
    if [ "$SKIP_NEXT" = "1" ]; then
        SKIP_NEXT=0
        shift
        continue
    fi
    case "$1" in
        -isystem)
            # Check if next arg is C++ include
            if [ $# -gt 1 ]; then
                case "$2" in
                    *include/c++*) SKIP_NEXT=1 ;;  # Skip both -isystem and path
                    *) CPPFLAGS_FIXED="$CPPFLAGS_FIXED $1" ;;  # Keep -isystem, path added next iteration
                esac
            fi
            ;;
        -isystem*include/c++*)
            ;;  # Skip combined form
        *include/c++*)
            ;;  # Skip standalone C++ paths
        *)
            CPPFLAGS_FIXED="$CPPFLAGS_FIXED $1"
            ;;
    esac
    shift
done
export CPPFLAGS="$CPPFLAGS_FIXED"
echo "Fixed CPPFLAGS (removed C++ includes): $CPPFLAGS"

# Set PYTHONPATH for mako from bdepends
IFS=':' read -ra DEP_ARRAY <<< "$DEP_BASE_DIRS"
for dep_dir in "${DEP_ARRAY[@]}"; do
    if [ -d "$dep_dir/lib/python" ]; then
        export PYTHONPATH="$dep_dir/lib/python${PYTHONPATH:+:$PYTHONPATH}"
    fi
done

# For cross-compilation, find the TARGET LLVM from dependencies (built with libstdc++)
# The host LLVM is built with libc++ which causes C++ ABI incompatibility
TARGET_LLVM_PREFIX=""
IFS=':' read -ra DEP_ARRAY_LLVM <<< "$DEP_BASE_DIRS"
for dep_dir in "${DEP_ARRAY_LLVM[@]}"; do
    if [ -f "$dep_dir/usr/lib/libLLVM.so" ] || [ -f "$dep_dir/usr/lib/libLLVM-21.so" ]; then
        TARGET_LLVM_PREFIX="$dep_dir/usr"
        echo "Found target LLVM at: $TARGET_LLVM_PREFIX"
        break
    fi
done

if [ -z "$TARGET_LLVM_PREFIX" ]; then
    echo "ERROR: Could not find target LLVM in dependencies"
    exit 1
fi

# Get LLVM version from the target
LLVM_VERSION="21.1.6"
LLVM_VERSION_MAJOR="21"

# Create llvm-config wrapper that returns target LLVM paths
# We can't run the target's llvm-config binary, so we create a script
mkdir -p llvm-wrapper
cat > llvm-wrapper/llvm-config << 'LLVMWRAPPER'
#!/bin/bash
# llvm-config wrapper for cross-compilation
# Returns paths to target LLVM instead of host LLVM
# Handles multiple options in a single call (like real llvm-config)

LLVM_PREFIX="__LLVM_PREFIX__"
LLVM_VERSION="__LLVM_VERSION__"
LLVM_VERSION_MAJOR="__LLVM_VERSION_MAJOR__"

# All available components (including AMDGPU which mesa needs)
ALL_COMPONENTS="aarch64 aarch64asmparser aarch64codegen aarch64desc aarch64disassembler aarch64info aarch64utils aggressiveinstcombine all all-targets amdgpu amdgpuasmparser amdgpucodegen amdgpudesc amdgpudisassembler amdgpuinfo amdgputargetmca amdgpuutils analysis arm armasmparser armcodegen armdesc armdisassembler arminfo armutils asmparser asmprinter binaryformat bitreader bitstreamreader bitwriter bpf bpfasmparser bpfcodegen bpfdesc bpfdisassembler bpfinfo cfguard codegen codegentypes core coroutines coverage debuginfocodeview debuginfodwarf debuginfogsym debuginfologicalview debuginfomsf debuginfopdb demangle dlltooldriver dwarflinker dwarflinkerclassic dwarflinkerparallel dwp engine executionengine extensions filecheck frontendatomic frontenddirective frontenddriver frontendhlsl frontendoffloading frontendopenacc frontentopenmp fuzzercli fuzzmutate globalisel instcombine instrumentation interfacestub interpreter ipo irprinter irreader jitlink libdriver lineeditor linker lto mc mca mcdisassembler mcjit mcparser mirparser native nativecodegen objcarcopts objcopy object objectyaml optdriver option orcdebugging orcjit orcshared orctargetprocess passes profiledata remarks runtimedyld sandboxir scalaropts selectiondag support symbolize tablegen tablegenbasic tablegencommon target targetparser telemetry textapi textapibinaryreader transformutils vectorize webassembly webassemblyasmparser webassemblycodegen webassemblydesc webassemblydisassembler webassemblyinfo webassemblyutils windowsdriver windowsmanifest x86 x86asmparser x86codegen x86desc x86disassembler x86info x86targetmca xray"

# Parse arguments - collect ALL options and modules
OPTIONS=()
MODULES=""
LINK_MODE="shared"

for arg in "$@"; do
    case "$arg" in
        --link-shared)
            LINK_MODE="shared"
            ;;
        --link-static)
            LINK_MODE="static"
            ;;
        --*)
            OPTIONS+=("$arg")
            ;;
        *)
            # This is a component/module name
            MODULES="$MODULES $arg"
            ;;
    esac
done

# If no options but modules given, treat as --libs query
if [ ${#OPTIONS[@]} -eq 0 ] && [ -n "$MODULES" ]; then
    OPTIONS=("--libs")
fi

# Output result for each option
OUTPUT=""
for OPTION in "${OPTIONS[@]}"; do
    case "$OPTION" in
        --version)
            OUTPUT="$OUTPUT $LLVM_VERSION"
            ;;
        --prefix)
            OUTPUT="$OUTPUT $LLVM_PREFIX"
            ;;
        --includedir)
            OUTPUT="$OUTPUT $LLVM_PREFIX/include"
            ;;
        --libdir)
            OUTPUT="$OUTPUT $LLVM_PREFIX/lib"
            ;;
        --bindir)
            OUTPUT="$OUTPUT $LLVM_PREFIX/bin"
            ;;
        --cppflags)
            OUTPUT="$OUTPUT -I$LLVM_PREFIX/include -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS"
            ;;
        --cflags)
            OUTPUT="$OUTPUT -I$LLVM_PREFIX/include -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS"
            ;;
        --cxxflags)
            OUTPUT="$OUTPUT -I$LLVM_PREFIX/include -std=c++17 -fno-exceptions -funwind-tables -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS"
            ;;
        --ldflags)
            OUTPUT="$OUTPUT -L$LLVM_PREFIX/lib"
            ;;
        --system-libs)
            OUTPUT="$OUTPUT -lrt -ldl -lpthread -lm -lz"
            ;;
        --libs)
            # When using shared library, just return -lLLVM regardless of modules requested
            if [ "$LINK_MODE" = "shared" ]; then
                OUTPUT="$OUTPUT -lLLVM-$LLVM_VERSION_MAJOR"
            else
                # For static linking, return per-component libraries (not implemented for simplicity)
                OUTPUT="$OUTPUT -lLLVM-$LLVM_VERSION_MAJOR"
            fi
            ;;
        --shared-mode)
            OUTPUT="$OUTPUT shared"
            ;;
        --has-rtti)
            OUTPUT="$OUTPUT YES"
            ;;
        --assertion-mode)
            OUTPUT="$OUTPUT OFF"
            ;;
        --build-mode)
            OUTPUT="$OUTPUT Release"
            ;;
        --targets-built)
            # Include AMDGPU for radeonsi
            OUTPUT="$OUTPUT AMDGPU;X86;AArch64;ARM;WebAssembly;BPF"
            ;;
        --components)
            OUTPUT="$OUTPUT $ALL_COMPONENTS"
            ;;
        --host-target)
            OUTPUT="$OUTPUT x86_64-unknown-linux-gnu"
            ;;
        *)
            echo "Unknown option: $OPTION" >&2
            exit 1
            ;;
    esac
done

# Output all results (trimmed leading whitespace)
echo "${OUTPUT# }"
LLVMWRAPPER

# Replace placeholders with actual values
sed -i "s|__LLVM_PREFIX__|$TARGET_LLVM_PREFIX|g" llvm-wrapper/llvm-config
sed -i "s|__LLVM_VERSION__|$LLVM_VERSION|g" llvm-wrapper/llvm-config
sed -i "s|__LLVM_VERSION_MAJOR__|$LLVM_VERSION_MAJOR|g" llvm-wrapper/llvm-config
chmod +x llvm-wrapper/llvm-config

LLVM_CONFIG="$(pwd)/llvm-wrapper/llvm-config"
echo "Created llvm-config wrapper at: $LLVM_CONFIG"
echo "LLVM wrapper --version: $($LLVM_CONFIG --version)"
echo "LLVM wrapper --libdir: $($LLVM_CONFIG --libdir)"
echo "LLVM wrapper --libs: $($LLVM_CONFIG --libs)"

# Find wayland-scanner from exec_bdepend (HOST_TOOL_DIRS or _EBUILD_HOST_TOOL_DIRS)
HOST_DIRS="${HOST_TOOL_DIRS:-$_EBUILD_HOST_TOOL_DIRS}"
if [ -n "$HOST_DIRS" ]; then
    IFS=':' read -ra HOST_ARRAY <<< "$HOST_DIRS"
    for host_dir in "${HOST_ARRAY[@]}"; do
        if [ -x "$host_dir/usr/bin/wayland-scanner" ]; then
            export PATH="$host_dir/usr/bin:$PATH"
            export PKG_CONFIG_PATH_FOR_BUILD="$(pwd)/patched_pkgconfig:$host_dir/usr/lib64/pkgconfig${PKG_CONFIG_PATH_FOR_BUILD:+:$PKG_CONFIG_PATH_FOR_BUILD}"
            break
        fi
    done
fi

echo "PYTHONPATH=$PYTHONPATH"
echo "PKG_CONFIG_PATH_FOR_BUILD=$PKG_CONFIG_PATH_FOR_BUILD"

# Create native file with llvm-config path for cross-compilation
cat > native.ini << NEOF
[binaries]
llvm-config = '$LLVM_CONFIG'
NEOF

NATIVE_FILE_ARG="--native-file=native.ini"
echo "Using native.ini:"
cat native.ini

# For cross-compilation: generate cross-file to tell meson about target architecture
CROSS_FILE_ARG=""
if [ "${CROSS_COMPILING:-false}" = "true" ] && [ -n "${CC:-}" ]; then
    # Detect target architecture from CHOST or compiler
    MESON_CPU_FAMILY="x86_64"
    MESON_CPU="x86_64"
    MESON_ENDIAN="little"

    TARGET_ARCH="${CHOST:-$(${CC:-gcc} -dumpmachine)}"
    case "$TARGET_ARCH" in
        aarch64*|arm64*)
            MESON_CPU_FAMILY="aarch64"
            MESON_CPU="aarch64"
            ;;
        x86_64*|amd64*)
            MESON_CPU_FAMILY="x86_64"
            MESON_CPU="x86_64"
            ;;
        arm*)
            MESON_CPU_FAMILY="arm"
            MESON_CPU="arm"
            ;;
        riscv64*)
            MESON_CPU_FAMILY="riscv64"
            MESON_CPU="riscv64"
            ;;
    esac

    # Generate meson cross-file with llvm-config for cross builds
    # Since we're building x86_64 target on x86_64 host, the host's llvm-config works
    cat > cross.ini << CROSSEOF
[binaries]
c = '${CC}'
cpp = '${CXX}'
ar = '${AR:-ar}'
strip = '${STRIP:-strip}'
pkgconfig = 'pkg-config'
llvm-config = '$LLVM_CONFIG'

[host_machine]
system = 'linux'
cpu_family = '$MESON_CPU_FAMILY'
cpu = '$MESON_CPU'
endian = '$MESON_ENDIAN'
CROSSEOF

    CROSS_FILE_ARG="--cross-file=cross.ini"
    echo "Using cross.ini for cross-compilation"
    cat cross.ini
fi

meson setup "${BUILD_DIR:-build}" \
    --prefix="${EPREFIX:-/usr}" \
    --libdir="${LIBDIR:-lib64}" \
    --buildtype="${MESON_BUILD_TYPE:-release}" \
    $NATIVE_FILE_ARG \
    $CROSS_FILE_ARG \
    ${MESON_EXTRA_ARGS:-}
''',
    use_meson = {
        # X11 support: enable GLX and X11 platform
        "X": "-Dplatforms=x11,wayland -Dglx=dri",
        "-X": "-Dplatforms=wayland -Dglx=disabled",
        # Vulkan drivers (Intel, AMD, software lavapipe)
        "vulkan": "-Dvulkan-drivers=intel,intel_hasvk,amd",
        "-vulkan": "-Dvulkan-drivers=",
        # LLVM support - enables llvmpipe and radeonsi
        # Driver set for AMD hardware (mesa 26.0.0):
        # - radeonsi: AMD GCN/RDNA (requires LLVM)
        # - llvmpipe: LLVM-accelerated software rendering
        # - virgl: Virtual GPU (QEMU/VirtIO)
        # Note: Intel drivers (iris/crocus) disabled as they require
        # SPIRV-LLVM-Translator in mesa 26.0.0 which we don't have yet
        # amd-use-llvm is required per Gentoo ebuild for AMD+LLVM builds
        "llvm": "-Dllvm=enabled -Damd-use-llvm=true -Dgallium-drivers=radeonsi,llvmpipe,virgl",
        "-llvm": "-Dllvm=disabled -Dgallium-drivers=softpipe,virgl",
    },
    use_deps = {
        # X11 dependencies for GLX and DRI
        "X": [
            "graphics//xorg/libX11:libX11",
            "graphics//xorg/libxcb:libxcb",
            "graphics//xorg/libXext:libXext",
            "graphics//xorg/libXfixes:libXfixes",
            "graphics//xorg/libXrandr:libXrandr",
            "graphics//xorg/libXxf86vm:libXxf86vm",
            "graphics//xorg/xorgproto:xorgproto",
            "graphics//xorg/libxshmfence:libxshmfence",
        ],
        # LLVM for radeonsi (AMD) and llvmpipe
        # libclc provides OpenCL C library needed for compute shaders
        "llvm": [
            "//packages/linux/core/llvm:llvm",
            "//packages/linux/core/libclc:libclc",
        ],
    },
    meson_args = [
        # Core features for mesa 26.0.0
        "-Degl=enabled",
        "-Dgbm=enabled",
        "-Dgles1=disabled",
        "-Dgles2=enabled",
        # Disable OpenCL/Rusticl to avoid SPIRV-LLVM-Translator requirement
        # We want LLVM for radeonsi rendering, not OpenCL compute
        "-Dgallium-rusticl=false",
    ],
    deps = [
        "//packages/linux/system/init/eudev:eudev",  # Provides libudev
        "//packages/linux/system/libs/input/libinput:libinput",
        "//packages/linux/desktop/libdrm:libdrm",
        "//packages/linux/graphics/rendering/wayland:wayland",
        "//packages/linux/graphics/rendering/wayland-protocols:wayland-protocols",
        "//packages/linux/system/libs/utility/libffi:libffi",
        "//packages/linux/system/libs/data/expat:expat",
        "//packages/linux/core/zlib:zlib",
        "//packages/linux/system/libs/compression/zstd:zstd",
        "//packages/linux/dev-libs/elfutils:elfutils",  # libelf for radeonsi
        "//packages/linux/dev-libs/spirv:spirv-tools",  # Required for SPIR-V shader compilation
    ],
    visibility = ["PUBLIC"],
)

# =============================================================================
# virglrenderer - Virtual 3D GPU for QEMU
# =============================================================================

meson_package(
    name = "virglrenderer",
    version = "1.2.0",
    src_uri = "https://gitlab.freedesktop.org/virgl/virglrenderer/-/archive/virglrenderer-1.2.0/virglrenderer-virglrenderer-1.2.0.tar.bz2",
    sha256 = "47a64189492a754685a430c713ac6700f4b1c3e7b871e87889ddb96e4d65e8ab",
    signature_required = False,
    description = "Library to implement a virtual 3D GPU used by qemu",
    homepage = "https://virgil3d.github.io/",
    license = "MIT",
    meson_args = [
        "-Dplatforms=egl",
        "-Dvulkan=false",
        "-Dtests=false",
    ],
    deps = [
        "//packages/linux/desktop/libdrm:libdrm",
        ":mesa",
    ],
    visibility = ["PUBLIC"],
)
