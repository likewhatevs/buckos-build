#!/bin/bash
# generate-ch-boot-script.sh — external generator for CH boot scripts.
# Receives artifact paths as positional args (resolved by buck2),
# string config via env vars. Writes the boot .sh directly.
set -e

OUTPUT="$1"
BOOT_MODE="$2"
KERNEL_DIR="$3"
INITRAMFS="$4"
DISK_IMAGE="$5"
FIRMWARE="$6"

: "${CH_CPUS:=2}"
: "${CH_MEMORY:=512M}"
: "${CH_KERNEL_ARGS:=console=ttyS0 quiet}"
: "${CH_SERIAL:=tty}"
: "${CH_EXTRA_ARGS:=}"
: "${CH_VIRTIOFS_SOCKET:=/tmp/virtiofs.sock}"
: "${CH_VIRTIOFS_TAG:=rootfs}"
: "${CH_VIRTIOFS_PATH:=/tmp/buckos-rootfs}"

# --- Helpers: write sections to $OUTPUT ---

_write_kernel_search() {
    cat >> "$OUTPUT" << EOF

# Paths to built artifacts
KERNEL_DIR="$KERNEL_DIR"

# Find kernel image
KERNEL=""
for k in "\$KERNEL_DIR/boot/vmlinuz"* "\$KERNEL_DIR/boot/bzImage" "\$KERNEL_DIR/vmlinuz"* "\$KERNEL_DIR/vmlinux"*; do
    if [ -f "\$k" ]; then
        KERNEL="\$k"
        break
    fi
done

if [ -z "\$KERNEL" ]; then
    echo "Error: Cannot find kernel image in \$KERNEL_DIR"
    exit 1
fi
echo "  Kernel: \$KERNEL"
EOF
}

_write_initramfs_check() {
    cat >> "$OUTPUT" << EOF

# Check initramfs
if [ ! -f "$INITRAMFS" ]; then
    echo "Error: Initramfs not found: $INITRAMFS"
    exit 1
fi
echo "  Initramfs: $INITRAMFS"
INITRAMFS_ARGS="--initramfs $INITRAMFS"
EOF
}

_write_disk_check() {
    cat >> "$OUTPUT" << EOF

# Check disk image
if [ ! -f "$DISK_IMAGE" ]; then
    echo "Error: Disk image not found: $DISK_IMAGE"
    exit 1
fi
echo "  Disk: $DISK_IMAGE"
DISK_ARGS="--disk path=$DISK_IMAGE"
EOF
}

_write_firmware_check() {
    cat >> "$OUTPUT" << EOF

# Check firmware
FIRMWARE="$FIRMWARE"
if [ ! -f "\$FIRMWARE" ]; then
    echo "Error: Firmware not found: \$FIRMWARE"
    exit 1
fi
echo "  Firmware: \$FIRMWARE"
EOF
}

# --- Preamble (no expansion — literal bash for the boot script) ---

cat > "$OUTPUT" << 'PREAMBLE'
#!/bin/bash
# Cloud Hypervisor Boot Script for BuckOs
# Generated by Buck2 build system

set -e
unset CDPATH

# Find project root by locating buck-out directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"
while [ "$PROJECT_ROOT" != "/" ]; do
    if [ -d "$PROJECT_ROOT/buck-out" ] && [ -f "$PROJECT_ROOT/.buckroot" -o -f "$PROJECT_ROOT/.buckconfig" ]; then
        break
    fi
    PROJECT_ROOT="$(dirname "$PROJECT_ROOT")"
done

if [ "$PROJECT_ROOT" = "/" ]; then
    # Fallback: assume script is in buck-out, find root by walking up past buck-out
    PROJECT_ROOT="$SCRIPT_DIR"
    while [[ "$PROJECT_ROOT" == *"/buck-out/"* ]]; do
        PROJECT_ROOT="$(dirname "$PROJECT_ROOT")"
    done
    PROJECT_ROOT="$(dirname "$PROJECT_ROOT")"
fi

cd "$PROJECT_ROOT"
PREAMBLE

# --- Mode-specific body ---

case "$BOOT_MODE" in
    direct)
        _write_kernel_search

        cat >> "$OUTPUT" << EOF

echo "Booting BuckOs with Cloud Hypervisor..."
echo "  Boot mode: direct"
EOF

        _write_initramfs_check

        if [ -n "$DISK_IMAGE" ]; then
            _write_disk_check
        else
            echo 'DISK_ARGS=""' >> "$OUTPUT"
        fi

        cat >> "$OUTPUT" << EOF

NET_ARGS=""
FS_ARGS=""
MEMORY_ARGS="size=$CH_MEMORY"

echo ""
echo "Press Ctrl-C to stop Cloud Hypervisor"
echo ""

# Direct kernel boot
exec cloud-hypervisor \\
    --cpus boot=$CH_CPUS \\
    --memory \$MEMORY_ARGS \\
    --kernel "\$KERNEL" \\
    \$INITRAMFS_ARGS \\
    --cmdline "$CH_KERNEL_ARGS" \\
    \$DISK_ARGS \\
    \$NET_ARGS \\
    \$FS_ARGS \\
    --serial $CH_SERIAL \\
    --console off \\
    $CH_EXTRA_ARGS \\
    "\$@"
EOF
        ;;

    firmware)
        _write_firmware_check
        _write_disk_check

        cat >> "$OUTPUT" << EOF

echo "Booting BuckOs with Cloud Hypervisor..."
echo "  Boot mode: firmware"

NET_ARGS=""
FS_ARGS=""
MEMORY_ARGS="size=$CH_MEMORY"

echo ""
echo "Press Ctrl-C to stop Cloud Hypervisor"
echo ""

# Firmware boot
exec cloud-hypervisor \\
    --cpus boot=$CH_CPUS \\
    --memory \$MEMORY_ARGS \\
    --kernel "\$FIRMWARE" \\
    \$DISK_ARGS \\
    \$NET_ARGS \\
    \$FS_ARGS \\
    --serial $CH_SERIAL \\
    --console off \\
    $CH_EXTRA_ARGS \\
    "\$@"
EOF
        ;;

    virtiofs)
        _write_kernel_search

        cat >> "$OUTPUT" << EOF

echo "Booting BuckOs with Cloud Hypervisor..."
echo "  Boot mode: virtiofs"
EOF

        _write_initramfs_check

        cat >> "$OUTPUT" << EOF

# VirtioFS configuration
VIRTIOFS_SOCKET="$CH_VIRTIOFS_SOCKET"
VIRTIOFS_PATH="\${VIRTIOFS_PATH:-$CH_VIRTIOFS_PATH}"

if [ ! -S "\$VIRTIOFS_SOCKET" ]; then
    echo "Starting virtiofsd..."
    echo "  Socket: \$VIRTIOFS_SOCKET"
    echo "  Share path: \$VIRTIOFS_PATH"

    # Ensure socket directory exists
    mkdir -p "\$(dirname "\$VIRTIOFS_SOCKET")"

    # Start virtiofsd
    virtiofsd --socket-path="\$VIRTIOFS_SOCKET" \\
        --shared-dir="\$VIRTIOFS_PATH" \\
        --cache=auto \\
        --sandbox=chroot &
    VIRTIOFS_PID=\$!
    echo "  virtiofsd PID: \$VIRTIOFS_PID"

    # Wait for socket
    for i in \$(seq 1 10); do
        if [ -S "\$VIRTIOFS_SOCKET" ]; then
            break
        fi
        sleep 0.5
    done

    if [ ! -S "\$VIRTIOFS_SOCKET" ]; then
        echo "Error: virtiofsd failed to start"
        exit 1
    fi
fi

FS_ARGS="--fs tag=$CH_VIRTIOFS_TAG,socket=\$VIRTIOFS_SOCKET"
NET_ARGS=""
# VirtioFS requires shared memory
MEMORY_ARGS="size=$CH_MEMORY,shared=on"

echo ""
echo "Press Ctrl-C to stop Cloud Hypervisor"
echo ""

# VirtioFS boot (rootfs via shared filesystem)
exec cloud-hypervisor \\
    --cpus boot=$CH_CPUS \\
    --memory \$MEMORY_ARGS \\
    --kernel "\$KERNEL" \\
    \$INITRAMFS_ARGS \\
    --cmdline "$CH_KERNEL_ARGS root=$CH_VIRTIOFS_TAG rootfstype=virtiofs rw" \\
    \$NET_ARGS \\
    \$FS_ARGS \\
    --serial $CH_SERIAL \\
    --console off \\
    $CH_EXTRA_ARGS \\
    "\$@"
EOF
        ;;

    *)
        echo "Error: Unknown boot mode: $BOOT_MODE" >&2
        exit 1
        ;;
esac

chmod +x "$OUTPUT"
