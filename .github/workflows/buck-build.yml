name: Buck Build Changed Targets

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  build-changed-targets:
    name: Build Changed Targets
    runs-on: ubuntu-latest
    outputs:
      quick_targets: ${{ steps.analyze-labels.outputs.quick_targets }}
      long_build_targets: ${{ steps.analyze-labels.outputs.long_build_targets }}
      skipped_targets: ${{ steps.analyze-labels.outputs.skipped_targets }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Install Buck2
        run: |
          # Download and install Buck2
          BUCK2_VERSION="latest"
          curl -LO "https://github.com/facebook/buck2/releases/download/${BUCK2_VERSION}/buck2-x86_64-unknown-linux-gnu.zst"
          zstd -d buck2-x86_64-unknown-linux-gnu.zst -o buck2
          chmod +x buck2
          sudo mv buck2 /usr/local/bin/
          buck2 --version

      - name: Install zstd
        run: |
          sudo apt-get update
          sudo apt-get install -y zstd

      - name: Get changed files
        id: changed-files
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare against the base branch
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            # For pushes, compare against the previous commit
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"

            # Handle the case of a new branch or force push
            if [ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]; then
              # New branch - compare against default branch
              BASE_SHA=$(git rev-parse origin/main 2>/dev/null || git rev-parse origin/master 2>/dev/null || echo "")
              if [ -z "$BASE_SHA" ]; then
                echo "Unable to determine base commit"
                echo "changed_files=" >> $GITHUB_OUTPUT
                exit 0
              fi
            fi
          fi

          echo "Comparing $BASE_SHA to $HEAD_SHA"

          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep -E '\.(bzl|BUCK)$|^BUCK$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No BUCK or .bzl files changed"
            echo "changed_files=" >> $GITHUB_OUTPUT
          else
            echo "Changed build files:"
            echo "$CHANGED_FILES"
            # Convert to single line for output
            CHANGED_FILES_ONELINE=$(echo "$CHANGED_FILES" | tr '\n' ' ')
            echo "changed_files=$CHANGED_FILES_ONELINE" >> $GITHUB_OUTPUT
          fi

      - name: Find affected targets
        id: affected-targets
        if: steps.changed-files.outputs.changed_files != ''
        run: |
          CHANGED_FILES="${{ steps.changed-files.outputs.changed_files }}"
          AFFECTED_TARGETS=""

          echo "Finding targets for changed files..."

          for file in $CHANGED_FILES; do
            if [ -f "$file" ]; then
              # Get directory containing the BUCK file
              if [[ "$file" == *"/BUCK" ]] || [[ "$file" == "BUCK" ]]; then
                DIR=$(dirname "$file")
                if [ "$DIR" == "." ]; then
                  PATTERN="//:"
                else
                  PATTERN="//${DIR}:"
                fi
              elif [[ "$file" == *".bzl" ]]; then
                # For .bzl files, we need to find all targets that might use them
                # This is a conservative approach - build all targets in affected packages
                DIR=$(dirname "$file")
                if [ "$DIR" == "." ] || [ "$DIR" == "defs" ]; then
                  # Changes to root defs might affect everything, but we'll be selective
                  PATTERN="//packages/..."
                else
                  PATTERN="//${DIR}/..."
                fi
              fi

              echo "File: $file -> Pattern: $PATTERN"

              # Get targets matching the pattern
              TARGETS=$(buck2 targets "$PATTERN" 2>/dev/null || echo "")
              if [ -n "$TARGETS" ]; then
                AFFECTED_TARGETS="$AFFECTED_TARGETS $TARGETS"
              fi
            fi
          done

          # Deduplicate targets
          if [ -n "$AFFECTED_TARGETS" ]; then
            UNIQUE_TARGETS=$(echo "$AFFECTED_TARGETS" | tr ' ' '\n' | sort -u | tr '\n' ' ')
            echo "Affected targets:"
            echo "$UNIQUE_TARGETS" | tr ' ' '\n'
            echo "targets=$UNIQUE_TARGETS" >> $GITHUB_OUTPUT
          else
            echo "No buildable targets found for changed files"
            echo "targets=" >> $GITHUB_OUTPUT
          fi

      - name: Analyze target labels
        id: analyze-labels
        if: steps.affected-targets.outputs.targets != ''
        run: |
          TARGETS="${{ steps.affected-targets.outputs.targets }}"

          # Arrays to hold categorized targets
          QUICK_TARGETS=""
          LONG_BUILD_TARGETS=""
          SKIPPED_TARGETS=""

          echo "========================================"
          echo "Analyzing target labels..."
          echo "========================================"

          for target in $TARGETS; do
            # Query target labels using buck2 cquery
            # Labels are returned as a JSON array
            LABELS=$(buck2 cquery "$target" --output-attribute labels 2>/dev/null | grep -o '"labels":\s*\[[^]]*\]' | sed 's/"labels":\s*//' || echo "[]")

            # Check for ci_skip label - these targets are completely skipped
            if echo "$LABELS" | grep -q '"ci_skip"'; then
              echo "SKIP (ci_skip): $target"
              SKIPPED_TARGETS="$SKIPPED_TARGETS $target"
              continue
            fi

            # Check for long_build label - these need special handling
            if echo "$LABELS" | grep -q '"long_build"'; then
              echo "LONG BUILD: $target"
              LONG_BUILD_TARGETS="$LONG_BUILD_TARGETS $target"
              continue
            fi

            # Default: quick build targets
            echo "QUICK: $target"
            QUICK_TARGETS="$QUICK_TARGETS $target"
          done

          echo ""
          echo "========================================"
          echo "Target Classification Summary"
          echo "========================================"

          QUICK_COUNT=$(echo "$QUICK_TARGETS" | wc -w)
          LONG_COUNT=$(echo "$LONG_BUILD_TARGETS" | wc -w)
          SKIP_COUNT=$(echo "$SKIPPED_TARGETS" | wc -w)

          echo "Quick build targets: $QUICK_COUNT"
          echo "Long build targets: $LONG_COUNT"
          echo "Skipped targets: $SKIP_COUNT"

          # Output the categorized targets
          echo "quick_targets=$QUICK_TARGETS" >> $GITHUB_OUTPUT
          echo "long_build_targets=$LONG_BUILD_TARGETS" >> $GITHUB_OUTPUT
          echo "skipped_targets=$SKIPPED_TARGETS" >> $GITHUB_OUTPUT

          # Also output counts for conditional job execution
          echo "quick_count=$QUICK_COUNT" >> $GITHUB_OUTPUT
          echo "long_count=$LONG_COUNT" >> $GITHUB_OUTPUT
          echo "skip_count=$SKIP_COUNT" >> $GITHUB_OUTPUT

      - name: Build quick targets
        if: steps.analyze-labels.outputs.quick_targets != ''
        run: |
          TARGETS="${{ steps.analyze-labels.outputs.quick_targets }}"

          echo "========================================"
          echo "Building quick targets..."
          echo "========================================"

          # Count targets
          TARGET_COUNT=$(echo "$TARGETS" | wc -w)
          echo "Total quick targets to build: $TARGET_COUNT"
          echo ""

          # Build each target individually to get clear error reporting
          FAILED_TARGETS=""
          PASSED_TARGETS=""

          for target in $TARGETS; do
            echo "----------------------------------------"
            echo "Building: $target"
            echo "----------------------------------------"

            if buck2 build "$target" 2>&1; then
              echo "✓ SUCCESS: $target"
              PASSED_TARGETS="$PASSED_TARGETS $target"
            else
              echo "✗ FAILED: $target"
              FAILED_TARGETS="$FAILED_TARGETS $target"
            fi
            echo ""
          done

          # Summary
          echo "========================================"
          echo "Quick Build Summary"
          echo "========================================"

          PASSED_COUNT=$(echo "$PASSED_TARGETS" | wc -w)
          FAILED_COUNT=$(echo "$FAILED_TARGETS" | wc -w)

          echo "Passed: $PASSED_COUNT"
          echo "Failed: $FAILED_COUNT"

          if [ -n "$FAILED_TARGETS" ]; then
            echo ""
            echo "Failed targets:"
            echo "$FAILED_TARGETS" | tr ' ' '\n'
            exit 1
          fi

          echo ""
          echo "All quick targets built successfully!"

      - name: Report skipped targets
        if: steps.analyze-labels.outputs.skipped_targets != ''
        run: |
          SKIPPED="${{ steps.analyze-labels.outputs.skipped_targets }}"

          echo "========================================"
          echo "Skipped Targets (ci_skip label)"
          echo "========================================"
          echo ""
          echo "The following targets were skipped due to ci_skip label:"
          echo "$SKIPPED" | tr ' ' '\n'
          echo ""
          echo "These are typically large packages like chromium, llvm, etc."
          echo "that would exceed CI time limits."

      - name: No changes to build
        if: steps.changed-files.outputs.changed_files == ''
        run: |
          echo "No BUCK or .bzl files were changed in this commit."
          echo "Skipping build validation."

      - name: No targets found
        if: steps.changed-files.outputs.changed_files != '' && steps.affected-targets.outputs.targets == ''
        run: |
          echo "Changed files were detected but no buildable targets were found."
          echo "This may indicate:"
          echo "  - Changes to non-target files (e.g., documentation in .bzl)"
          echo "  - Invalid BUCK file patterns"
          echo ""
          echo "Changed files:"
          echo "${{ steps.changed-files.outputs.changed_files }}" | tr ' ' '\n'

  # Separate job for long-running builds (optional, triggered manually or on schedule)
  build-long-targets:
    name: Build Long-Running Targets
    runs-on: ubuntu-latest
    needs: build-changed-targets
    if: needs.build-changed-targets.outputs.long_build_targets != ''
    # This job is set to manual trigger by default - uncomment 'if' above to auto-run
    # For very long builds, consider using self-hosted runners or scheduled jobs

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Install Buck2
        run: |
          BUCK2_VERSION="latest"
          curl -LO "https://github.com/facebook/buck2/releases/download/${BUCK2_VERSION}/buck2-x86_64-unknown-linux-gnu.zst"
          zstd -d buck2-x86_64-unknown-linux-gnu.zst -o buck2
          chmod +x buck2
          sudo mv buck2 /usr/local/bin/
          buck2 --version

      - name: Install zstd
        run: |
          sudo apt-get update
          sudo apt-get install -y zstd

      - name: Build long-running targets
        run: |
          TARGETS="${{ needs.build-changed-targets.outputs.long_build_targets }}"

          echo "========================================"
          echo "Building long-running targets..."
          echo "========================================"
          echo ""
          echo "Note: These targets have the 'long_build' label and may take"
          echo "significant time to complete."
          echo ""

          FAILED_TARGETS=""
          PASSED_TARGETS=""

          for target in $TARGETS; do
            echo "----------------------------------------"
            echo "Building: $target"
            echo "----------------------------------------"

            if buck2 build "$target" 2>&1; then
              echo "✓ SUCCESS: $target"
              PASSED_TARGETS="$PASSED_TARGETS $target"
            else
              echo "✗ FAILED: $target"
              FAILED_TARGETS="$FAILED_TARGETS $target"
            fi
            echo ""
          done

          # Summary
          echo "========================================"
          echo "Long Build Summary"
          echo "========================================"

          PASSED_COUNT=$(echo "$PASSED_TARGETS" | wc -w)
          FAILED_COUNT=$(echo "$FAILED_TARGETS" | wc -w)

          echo "Passed: $PASSED_COUNT"
          echo "Failed: $FAILED_COUNT"

          if [ -n "$FAILED_TARGETS" ]; then
            echo ""
            echo "Failed targets:"
            echo "$FAILED_TARGETS" | tr ' ' '\n'
            exit 1
          fi

    outputs:
      long_build_targets: ${{ needs.build-changed-targets.outputs.long_build_targets }}
